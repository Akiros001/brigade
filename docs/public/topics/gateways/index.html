<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Gateways - Brigade</title>
<meta name="description" content="How gateways work how to create your own.">
<meta name="generator" content="Hugo 0.54.0" />
<link href="/index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="/topics/gateways/">
<link rel="stylesheet" href="/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="/js/functions.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="/js/jquery.backtothetop/jquery.backtothetop.min.js"></script></head>
<body>
<div class="container"><header>
<h1>Brigade</h1>

<p class="description">Brigade - Event-driven scripting for Kubernetes.</p>
<div class="menu">
<nav>
<ul>
<li><a href="https://docs.brigade.sh">Docs</a></li>
<li><a href="https://github.com/Azure/brigade/tree/master/docs/content/examples">Examples</a></li>
<li><a href="https://github.com/azure/brigade">Github</a></li></ul>
</nav>
</div>
</header>
<div class="content-container">
<main>
  <article class="content-wrap"><h1>Gateways</h1>

<h1 id="brigade-gateways">Brigade Gateways</h1>

<p>This guide explains how gateways work, and provides guidance for creating your own
gateway.</p>

<h2 id="what-is-a-brigade-gateway">What Is A Brigade Gateway?</h2>

<p>The <a href="design.md">Brigade architecture</a> is oriented around the concept that Brigade
scripts run as a response to one or more events. In Brigade, a <em>gateway</em> is an
entity that generates events. Often times, it translates some external trigger
into a Brigade event.</p>

<p>Brigade ships with the ability to enable various gateways that are ready to go.</p>

<p>These include the <a href="dockerhub.md">Container Registry Gateway</a>, the <a href="./github.md">Github Gateway</a>
and the <a href="./genericgateway.md">Generic Gateway</a>.  They can all be enabled via top-level
Helm <a href="https://github.com/Azure/brigade-charts/blob/master/charts/brigade/values.yaml">chart flags</a>.</p>

<p>All of these provide HTTP-based listeners that receive incoming requests
(from a container registry, Github or other platforms and systems) and generate
Brigade events as a result.</p>

<p>However, Brigade&rsquo;s gateway system works with more than just webhooks.</p>

<p>For example, the <code>brig</code> client also acts as a gateway. When you execute a <code>brig run</code>
command, <code>brig</code> creates a Brigade event. By default, it emits an <code>exec</code> event. And
Brigade itself processes this event no differently than it processes the GitHub
or container registry events.</p>

<p>There are no rules about what can be used as a trigger for an event. One could
write a gateway that listens on a message queue, or runs as a chat bot, or watches
files on a filesystem&hellip; any of these could be used to trigger a new Brigade event.</p>

<p>The remainder of this guide explains how gateways work and how you can create custom
gateways.</p>

<h2 id="an-event-is-a-secret">An Event Is A Secret</h2>

<p>The most important thing to understand about a Brigade event is that it is simply
a <a href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes Secret</a>
with special labels and data.</p>

<p>When a new and appropriately labeled secret is created in Kubernetes, the Brigade
controller will read that secret and start a new Brigade worker to handle the event.
Secrets have several characteristics that make them a great fit for this role:</p>

<ul>
<li>They are designed to protect data (and we expect them to mature in this capacity)</li>
<li>They can be mounted as volumes and environment variables.</li>
<li>The payload of a secret is flexible</li>
<li>Secrets have been a stable part of the Kubernetes ecosystem since Kubernetes 1.2</li>
</ul>

<p>Because of these features, the Brigade system uses secrets for bearing event information.</p>

<h3 id="the-anatomy-of-a-brigade-event-secret">The Anatomy of a Brigade Event Secret</h3>

<p>Here is the structure of a Brigade event secret. It is annotated to explain what
data belongs in what fields.</p>

<pre><code class="language-yaml"># The main structure is a normal Kubernetes secret
apiVersion: v1
kind: Secret
metadata:
  # Every event has an automatically generated name. The main requirement of
  # this is that it MUST BE UNIQUE.
  name: example
  # Brigade uses several labels to determine whether a secret carries a
  # Brigade event.
  labels:
    # 'heritage: brigade' is mandatory, and signals that this is a Brigade event.
    heritage: brigade

    # This should point to the Brigade project ID in which this event is to be
    # executed
    project: brigade-1234567890

    # This MUST be a unique ID. Where possible, it SHOULD be a ULID
    # Substituting a UUID is fine, though some sorting functions won't be as
    # expected. (A UUID v1 will be sortable like ULIDs, but longer).
    build: 01C1R2SYTYAR2WQ2DKNTW8SH08

    # 'component: build' is REQUIRED and tells brigade to create a new build
    # record (and trigger a new worker run).
    component: build

    # Any other labels you add will be ignored by Brigade.
type: brigade.sh/build
data:
  # IMPORTANT: We show these fields as clear text, but they MUST be base-64
  # encoded.

  # The name of the thing that caused this event.
  event_provider: github

  # The type of event. This field is freeform. Brigade does not have a list of
  # pre-approved event names. Thus, you can define your own event_type
  event_type: push

  # Revision describes a vcs revision.
  revision:

    # Commit is the commitish/reference for any associated VCS repository. By
    # default, this should be `master` for Git.
    commit: 6913b2703df943fed7a135b671f3efdafd92dbf3

    # Ref is the symbolic ref name. (refs/heads/master, refs/pull/12/head, refs/tags/v0.1.0)
    ref: master

  # This should be the same as the `name` field on the secret
  build_name: example

  # This should be the same as the 'project' label
  project_id: brigade-1234567890

  # This should be the same as the 'build' label
  build_id: 01C1R2SYTYAR2WQ2DKNTW8SH08

  # The payload can contain arbitrary data that will be passed to the worker
  # JavaScript. It is passed to the script unparsed, and the script can parse
  # it as desired.
  payload: &quot;{ 'foo': 'bar' }&quot;

  # An event can supply a script to execute. If it does not supply a script,
  # Brigade will try to locate a 'brigade.js' file in the project's source
  # code repository using the commit provided above.
  script: &quot;console.log('hello');&quot;
</code></pre>

<p>Again, note that any fields in the <code>data:</code> section above are shown cleartext,
though in reality you <em>must</em> base-64 encode them.</p>

<p>The easiest way to create a secret like the above is to do so with the <code>kubectl</code>
command, though there are a host of language-specific libraries now for creating
secrets in code.</p>

<h2 id="creating-custom-gateways">Creating Custom Gateways</h2>

<p>Given the above description of how gateways work, we can now talk about a gateway
as anything that generates a secret following the format above.</p>

<p>In this final section, we will create a simple shell script that triggers a new
event every 60 seconds. In the payload, it sends the system time of the host
that is running the script.</p>

<pre><code class="language-bash">#!/usr/bin/env bash
set -euo pipefail

# The Kubernetes namespace in which Brigade is running.
namespace=&quot;default&quot;

event_provider=&quot;simple-event&quot;
event_type=&quot;my_event&quot;

# This is github.com/deis/empty-testbed
project_id=&quot;brigade-830c16d4aaf6f5490937ad719afd8490a5bcbef064d397411043ac&quot;
commit_ref=&quot;master&quot;
commit_id=&quot;589e15029e1e44dee48de4800daf1f78e64287c0&quot;

base64=(base64)
uuidgen=(uuidgen)
if [[ &quot;$(uname)&quot; != &quot;Darwin&quot; ]]; then
  base64+=(-w 0)
  uuidgen+=(-t) # generate UUID v1 for sortability
fi

# This is the brigade script to execute
script=$(cat &lt;&lt;EOF
const { events } = require(&quot;brigadier&quot;);
events.on(&quot;my_event&quot;, (e) =&gt; {
  console.log(&quot;The system time is &quot; + e.payload);
});
EOF
)

# Now we will generate a new event every 60 seconds.
while :; do
  # We'll use a UUID instead of a ULID. But if you want a ULID generator, you
  # can grab one here: https://github.com/technosophos/ulid
  uuid=&quot;$(&quot;${uuidgen[@]}&quot; | tr '[:upper:]' '[:lower:]')&quot;

  # We can use the UUID to make sure we get a unique name
  name=&quot;simple-event-$uuid&quot;

  # This will just print the system time for the system running the script.
  payload=$(date)

  cat &lt;&lt;EOF | kubectl --namespace ${namespace} create -f -
  apiVersion: v1
  kind: Secret
  metadata:
    name: ${name}
    labels:
      heritage: brigade
      project: ${project_id}
      build: ${uuid}
      component: build
  type: &quot;brigade.sh/build&quot;
  data:
    revision:
      commit: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${commit_id}&quot;)
      ref: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${commit_ref}&quot;)
    event_provider: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${event_provider}&quot;)
    event_type: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${event_type}&quot;)
    project_id: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${project_id}&quot;)
    build_id: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${uuid}&quot;)
    payload: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${payload}&quot;)
    script: $(&quot;${base64[@]}&quot; &lt;&lt;&lt;&quot;${script}&quot;)
EOF
  sleep 60
done
</code></pre>

<p>While the main point of the script above is just to show how to create a basic
event, it should also demonstrate how flexible the system is. A script can take
input from just about anything and use it to trigger a new event.</p>

<h2 id="creating-a-cron-job-gateway">Creating A Cron Job Gateway</h2>

<p>Beginning with the code above, we can build a gateway that runs as a scheduled
job in Kubernetes. In this example, we use a Kubernetes
<a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/">CronJob</a> object
to create the secret.</p>

<p>First we can begin with a simplified version of the script above. This one does not
run in a loop. It just runs once to completion.</p>

<p>Here is <code>cron-event.sh</code>:</p>

<pre><code class="language-bash">#!/usr/bin/env bash
set -euo pipefail

# The Kubernetes namespace in which Brigade is running.
namespace=${NAMESPACE:-default}

event_provider=&quot;simple-event&quot;
event_type=&quot;my_event&quot;
project_id=&quot;brigade-830c16d4aaf6f5490937ad719afd8490a5bcbef064d397411043ac&quot;
commit_ref=&quot;master&quot;
commit_id=&quot;589e15029e1e44dee48de4800daf1f78e64287c0&quot;
uuid=&quot;$(uuidgen | tr '[:upper:]' '[:lower:]')&quot;
name=&quot;simple-event-$uuid&quot;

payload=$(date)
script=$(cat &lt;&lt;EOF
const { events } = require(&quot;brigadier&quot;);
events.on(&quot;my_event&quot;, (e) =&gt; {
  console.log(&quot;The system time is &quot; + e.payload);
});
EOF
)

cat &lt;&lt;EOF | kubectl --namespace ${namespace} create -f -
apiVersion: v1
kind: Secret
metadata:
  name: ${name}
  labels:
    heritage: brigade
    project: ${project_id}
    build: ${uuid}
    component: build
type: &quot;brigade.sh/build&quot;
data:
  revision:
    commit: $(base64 -w 0 &lt;&lt;&lt;&quot;${commit_id}&quot;)
    ref: $(base64 -w 0 &lt;&lt;&lt;&quot;${commit_ref}&quot;)
  event_provider: $(base64 -w 0 &lt;&lt;&lt;&quot;${event_provider}&quot;)
  event_type: $(base64 -w 0 &lt;&lt;&lt;&quot;${event_type}&quot;)
  project_id: $(base64 -w 0 &lt;&lt;&lt;&quot;${project_id}&quot;)
  build_id: $(base64 -w 0 &lt;&lt;&lt;&quot;${uuid}&quot;)
  payload: $(base64 -w 0 &lt;&lt;&lt;&quot;${payload}&quot;)
  script: $(base64 -w 0 &lt;&lt;&lt;&quot;${script}&quot;)
EOF
</code></pre>

<p>Next, we will package the above as a Docker image. To do that, we create a <code>Dockerfile</code>
in the same directory as the <code>cron-event.sh</code> script above.</p>

<p>The <code>Dockerfile</code> just sets up the commands we need, and then copies the script into
the image:</p>

<pre><code class="language-Dockerfile">FROM debian:jessie-slim
RUN apt-get update &amp;&amp; apt-get install -y uuid-runtime curl
RUN curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl \
  &amp;&amp; mv kubectl /usr/local/bin/kubectl &amp;&amp; chmod 755 /usr/local/bin/kubectl
COPY ./cron-event.sh /usr/local/bin/cron-event.sh
CMD /usr/local/bin/cron-event.sh
</code></pre>

<p>(The really long line just installs <code>kubectl</code>)</p>

<p>And we can pack that into a Docker image by running <code>docker build -t technosophos/example-cron:latest .</code>.
You should replace <code>technosophos</code> with your Dockerhub username (or modify the
above to store in your Docker registry of choice).</p>

<p>Then push the image to a repository that your Kubernetes cluster can reach:</p>

<pre><code>$ docker push technosophos/example-cron
</code></pre>

<p>Now we create our third (and last) file: a CronJob definition. Our <code>cron.yaml</code>
should look something like this:</p>

<pre><code class="language-yaml">apiVersion: batch/v1beta1
kind: CronJob
metadata:
  name: example-cron-gateway
  labels:
    heritage: brigade
    component: gateway
spec:
  schedule: &quot;*/1 * * * *&quot;
  jobTemplate:
    spec:
      template:
        spec:
          restartPolicy: OnFailure
          containers:
            - name: cron-example
              image: technosophos/example-cron:latest
              imagePullPolicy: IfNotPresent
</code></pre>

<p>We can install it with <code>kubectl create -f cron.yaml</code>. Now, every minute our
new gateway will create an event.</p>

<p>Whenever you are done with this example, you can delete it with
<code>kubectl delete cronjob example-cron-gateway</code>.</p>

<p>That&rsquo;s it! We have create both a local shell script gateway and an in-cluster
cron gateway.</p>

<p>Again, there are other programming libraries and platforms that interoperate with
Kubernetes. Many of them are hosted on GitHub in the <a href="https://github.com/kubernetes-client">kubernetes-client org</a>.</p>

<hr />

<p>Prev: <a href="secrets.md">Using Secrets</a> <code>|</code> Next: <a href="projects.md">Projects</a></p>

<p>Return to the <a href="index.md">Table of Contents</a></p>
<div class="edit-meta"><small>Last updated on January 1, 0001 / Published on January 1, 0001</small>
<br></div><nav class="pagination"><a class="nav nav-prev" href="/topics/developers/" title="Developer Guide"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Developer Guide</a>
<a class="nav nav-next" href="/topics/genericgateway/" title="Generic Gateway">Next - Generic Gateway <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav></article>
<footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">
<nav>
<ul>
<li class=""><a href="/">Home</a></li>

<li class=""><a href="/intro/">Getting Started</a>
<ul class="">
<li class=""><a href="/intro/overview/">Brigade Overview</a></li>
<li class=""><a href="/intro/install/">Installing Brigade</a></li>
<li class=""><a href="/intro/tutorial01/">Tutorial 1: Writing a CI pipeline</a></li>
<li class=""><a href="/intro/tutorial02/">Tutorial 2: Setup GitHub</a></li>
<li class=""><a href="/intro/tutorial03/">Tutorial 3: Projects &amp; Events</a></li>
<li class=""><a href="/intro/tutorial04/">Tutorial 4: Writing a Test</a></li>
<li class=""><a href="/intro/writing-efficient-pipelines/">Tutorial 5: Writing Efficient Pipelines</a></li>
</ul>
  
</li>

<li class="parent"><a href="/topics/">Topic Guides</a>
<ul class="sub-menu">
<li class=""><a href="/topics/scripting_advanced/">Advanced Scripting Guide</a></li>
<li class=""><a href="/topics/dockerhub/">Container Registry Integration</a></li>
<li class=""><a href="/topics/dependencies/">Dependencies</a></li>
<li class=""><a href="/topics/design/">Design</a></li>
<li class=""><a href="/topics/developers/">Developer Guide</a></li>
<li class="active"><a href="/topics/gateways/">Gateways</a></li>
<li class=""><a href="/topics/genericgateway/">Generic Gateway</a></li>
<li class=""><a href="/topics/github/">GitHub Integration</a></li>
<li class=""><a href="/topics/ingress/">Ingress</a></li>
<li class=""><a href="/topics/projects/">Managing Projects in Brigade</a></li>
<li class=""><a href="/topics/releasing/">Releasing Brigade</a></li>
<li class=""><a href="/topics/scripting/">Scripting Guide</a></li>
<li class=""><a href="/topics/secrets/">Secret Management</a></li>
<li class=""><a href="/topics/security/">Securing Brigade</a></li>
<li class=""><a href="/topics/storage/">Storage</a></li>
<li class=""><a href="/topics/testing/">Testing</a></li>
<li class=""><a href="/topics/javascript/">The Brigade.js API</a></li>
<li class=""><a href="/topics/readnext/">What to Read Next</a></li>
<li class=""><a href="/topics/workers/">Workers</a></li>
</ul>
  
</li>
</ul>
</nav>


<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
