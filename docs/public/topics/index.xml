<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Topic Guides on Brigade</title>
    <link>/topics/</link>
    <description>Recent content in Topic Guides on Brigade</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="/topics/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advanced Scripting Guide</title>
      <link>/topics/scripting_advanced/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/scripting_advanced/</guid>
      <description>Advanced Scripting Guide This guide provides some tips and ideas for advanced scripting. It assumes that you are familiar with the scripting guide and the JavaScript API.
Using async and await to run Jobs Recent versions of JavaScript added a new way of declaring asynchronous methods, and then calling them. This way is compatible with promises. Brigade supports the new async and await decorators.
Here&amp;rsquo;s a simple Promise chain that calls two jobs:</description>
    </item>
    
    <item>
      <title>Container Registry Integration</title>
      <link>/topics/dockerhub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/dockerhub/</guid>
      <description>Container Registry (DockerHub, ACR) Integration Brigade supports container registry webhooks such as the ones emitted by DockerHub and ACR. The following platforms are known to work with Brigade&amp;rsquo;s Container Registry gateway:
 DockerHub Azure Container Registry (ACR) with the Managed_* classes  DockerHub/ACR integration is not enabled by default.
Intro to Container Registry Webhook Integration Brigade comes with built-in support for container registry image pushing events. When a container registry webhook system is configured to notify Brigade&amp;rsquo;s GW server, Brigade will respond to an image push by triggering an image_push event.</description>
    </item>
    
    <item>
      <title>Dependencies</title>
      <link>/topics/dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/dependencies/</guid>
      <description>Import dependencies in your brigade.js file A Brigade worker is responsible for executing your brigade.js file. By default, Brigade comes with a general purpose worker which does not have any external dependency that is not critical to controlling the flow of your pipeline.
If you want to have other dependencies available in your worker execution environment (and available in brigade.js), there are multiple approaches:
 by creating a custom worker container image, which has your dependencies.</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>/topics/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/design/</guid>
      <description>Brigade Design This is a living document, and is kept up to date with the current state of Brigade. It is a high-level explanation of the Brigade design.
Brigade is an in-cluster runtime environment. It interprets scripts, and executes them often by invoking resources inside of the cluster. Brigade is event-based scripting of Kubernetes pipelines.
 Event-based: A script execution is triggered by a Brigade event. Scripting: Programs are expressed as JavaScript files that declare one or more event handlers.</description>
    </item>
    
    <item>
      <title>Developer Guide</title>
      <link>/topics/developers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/developers/</guid>
      <description>Developer Guide This document explains how to get started developing Brigade.
Brigade is composed of numerous parts. The following represent the core components:
 brigade-controller: The Kubernetes controller for delegating Brigade events brigade-worker: The JavaScript runtime for executing brigade.js files. The controller spawns these, though you can run one directly as well. brigade-api: The REST API server for user interfaces brigade-project: The Helm chart for installing Brigade projects brigade-vacuum: The stale build cleaner-upper (optional; enabled by default) brig: The Brigade CLI git-sidecar: The code that runs as a sidecar in cluster to fetch Git repositories (optional; enabled by default)  Additionally, there are several opt-in gateways that can be enabled via Helm chart values.</description>
    </item>
    
    <item>
      <title>Gateways</title>
      <link>/topics/gateways/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/gateways/</guid>
      <description>Brigade Gateways This guide explains how gateways work, and provides guidance for creating your own gateway.
What Is A Brigade Gateway? The Brigade architecture is oriented around the concept that Brigade scripts run as a response to one or more events. In Brigade, a gateway is an entity that generates events. Often times, it translates some external trigger into a Brigade event.
Brigade ships with the ability to enable various gateways that are ready to go.</description>
    </item>
    
    <item>
      <title>Generic Gateway</title>
      <link>/topics/genericgateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/genericgateway/</guid>
      <description>Generic Gateway Brigade contains a Generic Gateway that can be used to accept requests from other platforms or systems. Generic Gateway is a separate component in the Brigade system, like Github and Container Registry (CR) Gateways.
Generic Gateway is not enabled by default and provides Brigade developers with the ability to trigger scripts based on messages received from any platform that can send a POST HTTP request.
Intro to Generic Gateway Generic Gateway listens and accepts POST JSON messages at two different endpoints, /simpleevents/v1/:projectID/:secret and /cloudevents/v02/:projectID/:secret.</description>
    </item>
    
    <item>
      <title>GitHub Integration</title>
      <link>/topics/github/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/github/</guid>
      <description>GitHub Integration Brigade can optionally provide GitHub integration for triggering Brigade builds from GitHub events via the Brigade Github App project. By default, this gateway is disabled.
To get set up, follow the instructions to create and configure a GitHub App. This App can then be used across one or more repositories, as opposed to the older, OAuth approach requiring configuration for each individual respository.
Next, to enable this gateway for a Brigade installation, set the brigade-github-app.</description>
    </item>
    
    <item>
      <title>Ingress</title>
      <link>/topics/ingress/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/ingress/</guid>
      <description>Using an ingress So you&amp;rsquo;ve got yourself a Kubernetes cluster somewhere in the cloud and you want to expose all your Brigade gateways using a Kubernetes ingress, and you might also want to configure automatic TLS for each new ingress. This document will guide you through an opinionated way of achieving this. Note that you should be able to switch any component and replace it with something else.
Requirements To follow along, you will need:</description>
    </item>
    
    <item>
      <title>Managing Projects in Brigade</title>
      <link>/topics/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/projects/</guid>
      <description>Managing Projects in Brigade In Brigade, a project is just a special Kubernetes secret. The Brigade project currently offers two methods to create a project: via the brig cli and via the brigade-project Helm chart. The latter is managed in the Azure/brigade-charts repo and an in-depth overview of its configuration can be seen in the chart README.
This document explains how to use both methods for managing your Brigade projects.</description>
    </item>
    
    <item>
      <title>Releasing Brigade</title>
      <link>/topics/releasing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/releasing/</guid>
      <description>Releasing Brigade Once the intended commit has been tested and we have confidence to cut a release, we can follow these steps to release Brigade:
 Issue a docs pull request with all &amp;lt;current release&amp;gt; strings updated to &amp;lt;anticipated release&amp;gt;, e.g. 0.19.0 becomes 0.20.0.
(Note: amending docs/index.yaml is not required. This file still exists (as of writing) only to serve older chart versions for a period of time after the chart migration to Azure/brigade-charts completed.</description>
    </item>
    
    <item>
      <title>Scripting Guide</title>
      <link>/topics/scripting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/scripting/</guid>
      <description>Scripting Guide This guide explains the basics of how to create and structure brigade.js files.
Brigade Scripts, Projects, and Repositories Brigade scripts are stored in a brigade.js file. They are designed to contain short scripts that coordinate running multiple related tasks. We like to think of these as cluster-oriented shell scripts: The script just ties together a bunch of other programs.
At the very core, a Brigade script is simply a JavaScript file that is executed within a special cluster environment.</description>
    </item>
    
    <item>
      <title>Secret Management</title>
      <link>/topics/secrets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/secrets/</guid>
      <description>Secret Management Brigade provides tools for storing sensitive data outside of your brigade.js scripts, and then passing that information into the jobs that need them. Brigade accomplishes this by making use of Kubernetes secrets.
Adding a Secret to Your Project Imagine a case where we need to pass a sensitive piece of information to one of the jobs in our brigade.js. For example, we might need to pass an authentication token to a job that must authenticate to a remote service.</description>
    </item>
    
    <item>
      <title>Securing Brigade</title>
      <link>/topics/security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/security/</guid>
      <description>Securing Brigade The execution of Brigade scripts involves dynamically creating (and destroying) a number of Kubernetes objects, including pods, secrets, and persistent volume claims. For that reason, it is prudent to configure security.
 Isolate Brigade in a namespace: It is best to run Brigade in its own namespace. For example, in a Helm install, do helm install --namespace brigade .... RBAC Enabled: When installing with Helm, role-based access control is enabled by default.</description>
    </item>
    
    <item>
      <title>Storage</title>
      <link>/topics/storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/storage/</guid>
      <description>How Brigade uses Kubernetes Persistent Storage Brigade allows script authors to declare two kinds of storage:
 per-job caches, which persist across builds per-build shared storage, which exists as long as the build is running  Usage of these is described within the JavaScript docs and the scripting guide.
This document describes the underlying Kubernetes architecture of these two storage types.
Brigade and PersistentVolumeClaims Brigade provisions storage using Kubernetes PVCs.</description>
    </item>
    
    <item>
      <title>Testing</title>
      <link>/topics/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/testing/</guid>
      <description>Testing Brigade Scripts Now that we&amp;rsquo;ve written our brigade.js scripts, we&amp;rsquo;re ready to confirm that the Javascript is correct and functioning as intended. Here we demonstrate the use of a few utilities we can employ to do so.
Javascript testing with brigtest brigtest is a testing tool designed to vet the Javascript portion of a brigade.js script without actually launching any containers or requiring a Kubernetes cluster. It can optionally mock events, Jobs and projects.</description>
    </item>
    
    <item>
      <title>The Brigade.js API</title>
      <link>/topics/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/javascript/</guid>
      <description>The Brigade.js API This document describes the public APIs typically used for writing Brigade.js. It does not describe internal libraries, nor does it list non-public methods and properties on these objects.
An Brigade JavaScript file is executed inside of a cluster. It runs inside of a Node.js-like environment (with a few libraries blocked for security reasons). It uses Node 8.
High-level Concepts An Brigade JS file is always associated with a project.</description>
    </item>
    
    <item>
      <title>Workers</title>
      <link>/topics/workers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/workers/</guid>
      <description>Adding custom libraries to a Brigade worker A worker is the component in Brigade that executes a brigade.js. Brigade ships with a general purpose worker focused on running jobs. This generic worker exposes a host of Node.js libraries to brigade.js files, as well as the brigadier Brigade library.
Sometimes, though, it is desirable to include additional libraries &amp;ndash; perhaps even custom libraries &amp;ndash; to your workers. There are two ways of adding custom dependencies to a Brigade worker:</description>
    </item>
    
  </channel>
</rss>