<!DOCTYPE html>
<html lang="en">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>The Brigade.js API - Brigade</title>
<meta name="description" content="Describing the public APIs typically used for writing Brigade.js">
<meta name="generator" content="Hugo 0.54.0" />
<link href="/index.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="/topics/javascript/">
<link rel="stylesheet" href="/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="/js/functions.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="/js/jquery.backtothetop/jquery.backtothetop.min.js"></script></head>
<body>
<div class="container"><header>
<h1>Brigade</h1>

<p class="description">Brigade - Event-driven scripting for Kubernetes.</p>
<div class="menu">
<nav>
<ul>
<li><a href="https://docs.brigade.sh">Docs</a></li>
<li><a href="https://github.com/Azure/brigade/tree/master/docs/content/examples">Examples</a></li>
<li><a href="https://github.com/azure/brigade">Github</a></li></ul>
</nav>
</div>
</header>
<div class="content-container">
<main>
  <article class="content-wrap"><h1>The Brigade.js API</h1>

<h1 id="the-brigade-js-api">The Brigade.js API</h1>

<p>This document describes the public APIs typically used for writing Brigade.js. It does not
describe internal libraries, nor does it list non-public methods and properties on
these objects.</p>

<p>An Brigade JavaScript file is executed inside of a cluster. It runs inside of a
Node.js-like environment (with a few libraries blocked for security reasons). It
uses Node 8.</p>

<h2 id="high-level-concepts">High-level Concepts</h2>

<p>An Brigade JS file is always associated with a <em>project</em>. A project defines contextual
information, and also dictates the security parameters under which the script will
execute.</p>

<p>A project may associate the script to a <em>repository</em>, where a repository is typically
a VCS reference (e.g. a git repository). Each job will, by default, have access
to the project&rsquo;s repository.</p>

<p>Brigade files respond to <em>events</em>. That is, Brigade scripts are typically composed of one or
more <em>event handlers</em>. When the Brigade environment triggers an event, the associated
event handler will be called.</p>

<h2 id="the-brigadier-library">The <code>brigadier</code> Library</h2>

<p>The main library for Brigade is called <code>brigadier</code>. The Brigade runtime grants access to
this library.  The source code for this library is located in <a href="https://github.com/Azure/brigadier">Azure/brigadier</a>.</p>

<pre><code>const brigadier = require('brigadier')
</code></pre>

<p>It is considered idiomatic to destructure the library on import:</p>

<pre><code>const { events, Job, Group } = require('brigadier')
</code></pre>

<p>Some objects described in this document are not declared in <code>brigadier</code>, but are
exposed via <code>brigadier</code>.</p>

<h3 id="the-brigadeevent-class">The <code>BrigadeEvent</code> class</h3>

<p>The <code>BrigadeEvent</code> class describes an event. Typically, it is exposed to the script
via a callback handler.</p>

<pre><code>events.on(&quot;pull&quot;, (brigadeEvent, project) =&gt; {})
</code></pre>

<p>An instance of an <code>BrigadeEvent</code> has the following properties:</p>

<ul>
<li><code>buildID: string</code>: The unique ID for the build. This will change for each build.</li>
<li><code>type: string</code>: The event type (<code>push</code>, <code>exec</code>, <code>pull_request</code>).</li>
<li><code>provider: string</code>: The name of the thing that triggered this event.</li>
<li><code>revision: Revision</code>: The revision details, if supplied, of the underlying VCS system.</li>
<li><code>payload: string</code>: Arbitrary data supplied by an event emitter. Each event emitter
will describe its own payload. For example, the GitHub gateway emits events that
contain GitHub&rsquo;s webhook objects.</li>
<li><code>cause: Cause</code>: If one event triggers another event, the causal chain is passed
through the <code>cause</code> property</li>
</ul>

<h3 id="the-revision-object">The <code>revision</code> object</h3>

<p>The <code>revision</code> object has the following properties:</p>

<ul>
<li><code>commit: string</code>: The commit ID, if supplied, for the underlying VCS system. When this is supplied, each Job will have access to the VCS at this revision.</li>
<li><code>ref: string</code>: The symbolic ref name. (e.g <code>refs/heads/master</code>)</li>
</ul>

<p>If the <code>revision</code> object is not provided, it may be interpreted as <code>master</code>, or the head of the main branch.
<em>The default value is not guaranteed to be <code>master</code> in future versions.</em></p>

<h4 id="the-cause-class">The <code>Cause</code> class</h4>

<p>A <code>Cause</code> is attached to an <code>BrigadeEvent</code>, and describes the event that caused this
event. It has the following properties:</p>

<ul>
<li><code>event: BrigadeEvent</code>: The causing event</li>
<li><code>reason: any</code>: The reason this event was caused. Typically this is an error object.</li>
<li><code>trigger: string</code>: The mechanism that triggered this event (e.g. &ldquo;unhandled exception&rdquo;)</li>
</ul>

<p>The <code>after</code> and <code>error</code> built-in events will set a <code>Cause</code> on their <code>BrigadeEvent</code> objects.</p>

<h3 id="the-events-object">The <code>events</code> Object</h3>

<p>Within <code>brigadier</code>, the <code>events</code> object provides access to the main event handler.</p>

<h4 id="events-on-eventname-string-callback-e-brigadeevent-p-project"><code>events.on(eventName: string, callback: (e: BrigadeEvent, p: Project) =&gt; {})</code></h4>

<p>The <code>events.on()</code> function is the way event handlers are registered. An <code>on()</code> method
takes two arguments: the name of the event and the callback that will be executed
when the named event fires.</p>

<pre><code class="language-javascript">events.on(&quot;push&quot;, (e, p) =&gt; {
  console.log(p.name);
});
</code></pre>

<h4 id="events-has-eventname-string-boolean"><code>events.has(eventName: string): boolean</code></h4>

<p><code>events.has</code> is used to see if an event handler was registered already.</p>

<h3 id="the-group-class">The <code>Group</code> class</h3>

<p>The <code>Group</code> class provides both static methods and object methods for working
with groups.</p>

<h4 id="the-static-runall-job-promise-result-method">The static <code>runAll(Job[]): Promise&lt;Result[]&gt;</code> method</h4>

<p>The <code>runAll</code> method runs all jobs in parallel, and returns a Promise that waits until
all jobs are done and then returns the collected results.</p>

<p>This is useful for running a batch of jobs in parallel, but waiting until they are
complete before continuing with another operation.</p>

<h4 id="the-static-runeach-job-promise-result-method">The static <code>runEach(Job[]): Promise&lt;Result[]&gt;</code> method</h4>

<p>This runs each of the given jobs in sequence, blocking on each job until it
is complete. The Promise will return the collected results.</p>

<h4 id="the-new-group-job-group-constructor">The <code>new Group(Job[]): Group</code> constructor</h4>

<p>Create a new <code>Group</code> and optionally pass it some jobs.</p>

<h4 id="the-add-job-method">The <code>add(Job...)</code> method</h4>

<p>Adds one or more Job objects to the group.</p>

<h4 id="the-length-number-method">The <code>length(): number</code> method</h4>

<p>Return how many jobs are in the group.</p>

<h4 id="the-runall-promise-result-method">The <code>runAll(): Promise&lt;Result[]&gt;</code> method</h4>

<p>Runs all of the jobs in the group in parallel. When the Promise resolves, it will
wrap all of the results.</p>

<p>Functionally, this is equivalent to the static <code>runAll</code> method.</p>

<h4 id="the-runeach-method">The <code>runEach</code> method</h4>

<p>Runs each of the jobs in sequence (synchronously). When the Promise resolves, it will
wrap all of the results.</p>

<p>Functionally, this is equivalent to the static <code>runEach</code> method.</p>

<h3 id="the-job-class">The <code>Job</code> class</h3>

<p>The <code>Job</code> class describes a job that can be run.</p>

<h4 id="constructor-new-job-name-string-image-string-tasks-string-imageforcepull-boolean-job">constructor <code>new Job(name: string, image?: string, tasks?: string[], imageForcePull?: boolean): Job</code></h4>

<p>The constructor requires a <code>name</code> parameter, and this must be unique within your
script. It must be composed of the characters a-z, A-Z, 0-9, and <code>-</code>. Additionally,
the <code>-</code> cannot be the first or last character, and the name must be at least two
characters.</p>

<p>Optionally, you may specify the container image (e.g. <code>node:8</code>, <code>alpine:3.4</code>). The
container image must be fetchable by the runtime (Kubernetes). If no container is
specified here or with <code>Job.image</code>, a default image will be loaded.</p>

<p>Optionally, you may specify a list of tasks to be run inside of the container. If no
tasks are specified here or with <code>Job.tasks</code>, the container will be run with its
defaults.</p>

<p>These two are equivalent:</p>

<pre><code class="language-javascript">var one = new Job(&quot;one&quot;);
one.image = &quot;alpine:3.4&quot;;
one.tasks = [&quot;echo hello&quot;];

var two = new Job(&quot;two&quot;, &quot;alpine:3.4&quot;, [&quot;echo hello&quot;]);
</code></pre>

<p>Properties of <code>Job</code></p>

<ul>
<li><code>name: string</code>: The job name</li>
<li><code>shell: string</code>: The shell in which to execute the tasks (<code>/bin/sh</code>)</li>
<li><code>tasks: string[]</code>: Tasks to be run in the job, in order. Tasks are concatenated
together and packaged as a Borne (<code>/bin/sh</code>) shell script with <code>set -eo pipefail</code>.</li>
<li><code>args: string[]</code>: Arguments to pass to the container&rsquo;s entrypoint. It is recommended,
though not required, that implementors not use both <code>args</code> and <code>tasks</code>.</li>
<li><code>imageForcePull: boolean</code>: Defines the container image pull policy: <code>Always</code> if <code>true</code> or <code>IfNotPresent</code> if <code>false</code> (defaults to <code>false</code>).</li>
<li><code>env: {[key: string]:string}</code>: Name/value pairs of environment variables.</li>
<li><code>image: string</code>: The container image to run</li>
<li><code>imagePullSecrets: string[]</code>: The names of the pull secrets (for pulling images from a secure remote repository)</li>
<li><code>mountPath: string</code>: The path where any resources should be mounted (e.g. where a Git repository will be cloned) (defaults to <code>/src</code>)</li>
<li><code>timeout: number</code>: Time to wait, in milliseconds, before the job is marked &ldquo;failed&rdquo;</li>
<li><code>useSource: bool</code>: If false, no external resource will be loaded (e.g. no git clone will be performed)</li>
<li><code>privileged: bool</code>: If this is true, the job will be executed in privileged mode, which allows it to do things like access a Docker socket. EXPERTS ONLY.</li>
<li><code>host: JobHost</code>: Preferences for the host that runs the job.</li>
<li><code>cache: JobCache</code>: Preferences for the job&rsquo;s cache</li>
<li><code>storage: JobStorage</code>: Preferences for the way this job attaches to the build storage</li>
<li><code>docker: JobDockerMount</code>: Preferences for mounting a Docker socket</li>
<li><code>serviceAccount: string</code>: The name of the service account to use (if you need to override the default).</li>
<li><code>annotations: {[key: string]:string}</code>: Name/value pairs of annotations to add to the job&rsquo;s pod</li>
<li><code>resourceRequests: JobResourceRequest</code>: CPU and memory request resources for the job pod container.</li>
<li><code>resourceLimits: JobResourceLimit</code>: CPU and memory limit resources for the job pod container.</li>
<li><code>streamLogs: boolean</code>: controls whether logs from the job Pod will be streamed to output (similar functionality to <code>kubectl logs PODNAME -f</code>).</li>
</ul>

<h4 id="setting-execution-resources-to-a-job">Setting execution resources to a job</h4>

<p>For some jobs is a good practice to set limits and guarantee some resources. In the following example job pod container resource requests and limits are set.</p>

<pre><code class="language-javascript">var job = new Job(&quot;huge-job&quot;);

// Our job uses a lot of resources, we set huge requests but set safe memory limits:
job.resourceRequests.memory = &quot;2Gi&quot;;
job.resourceRequests.cpu = &quot;500m&quot;;
job.resourceLimits.memory = &quot;3Gi&quot;;
job.resourceLimits.cpu = &quot;1&quot;;
</code></pre>

<p>All are optional, for example you could set only <code>resourceLimits.memory = 3Gi</code>).</p>

<h4 id="the-job-podname-method">The <code>job.podName()</code> method</h4>

<p>This returns the name of the pod that was started during <code>job.run()</code>. It will return
an empty string before <code>run()</code> is called.</p>

<h4 id="the-job-run-promise-result-method">The <code>job.run(): Promise&lt;Result&gt;</code> method</h4>

<p>Run the job, returning a Promise that returns when the job is complete.</p>

<h3 id="the-jobcache-class">The <code>JobCache</code> class</h3>

<p>A <code>JobCache</code> object provides preferences for a job&rsquo;s usage of a cache.</p>

<p>Caches are disabled by default.</p>

<p>Properties:</p>

<ul>
<li><code>enabled: boolean</code>: If <code>true</code>, the cache is turned on for this job.</li>
<li><code>size: string</code>: The size, defaults to <code>5Mi</code>. This value is only evaluated the first
time a job is cached. To resize, the cache must be destroyed manually.</li>
<li><code>path: string</code>: A read-only attribute returning path (in the container) in which the cache
is available.</li>
</ul>

<h3 id="the-jobdockermount-class">The <code>JobDockerMount</code> class</h3>

<p>The <code>JobDockerMount</code> controls whether, and how, a Docker socket is mounted to
the job. Docker sockets are used for building Docker images. Because they mount
to the host, using a Docker socket is considered dangerous. Thus, to use the
Docker mount, the job must be put into <code>privileged</code> mode.</p>

<p>Properties:</p>

<ul>
<li><code>enabled: boolean</code>: If <code>true</code>, the Docker socket will be mounted to the pod</li>
</ul>

<h3 id="the-jobhost-class">The <code>JobHost</code> class</h3>

<p>A <code>JobHost</code> object provides preferences for the host upon which the job is executed.</p>

<ul>
<li><code>os: string</code>: The name of the OS upon which the job should be run (<code>linux</code>, <code>windows</code>).
Not all clusters support all OSes.</li>
<li><code>name: string</code>: The name of the host (node) upon which the job will run. This is
highly system dependent.</li>
</ul>

<h3 id="the-jobstorage-class">The <code>JobStorage</code> class</h3>

<ul>
<li><code>enabled: boolean</code>: If set to <code>true</code>, the Job will mount the build storage.
Build storage exposes a mounted volume at <code>/mnt/brigade/share</code> with storage that
can be shared across jobs.</li>
<li><code>path: string</code>: The read-only path to the shared storage from within the container.</li>
</ul>

<h3 id="the-kubernetesconfig-class">The <code>KubernetesConfig</code> class</h3>

<p>A KubernetesConfig object has the following properties:</p>

<ul>
<li><code>namespace: string</code>: The namespace in which Kubernetes objects are created.</li>
<li><code>vcsSidecar: string</code>: The name of the sidecar image that fetches the repository.
By default, this is the Git sidecar that fetches git repositories.</li>
<li><code>buildStorageSize: string</code>: The size of the build shared storage space used by the build jobs.</li>
</ul>

<h3 id="the-result-class">The <code>Result</code> class</h3>

<p>This wraps the result of a Job run.</p>

<h4 id="the-tostring-string-method">The <code>toString(): string</code> method</h4>

<p>This returns the result as a string.</p>

<h3 id="the-project-class">The <code>Project</code> class</h3>

<p>Properties:</p>

<ul>
<li><code>id: string</code>: The unique ID of the project</li>
<li><code>name: string</code>: The project name, typically <code>org/name</code>.</li>
<li><code>kubernetes: KubernetesConfig</code>: The object describing this project&rsquo;s Kubernetes settings</li>
<li><code>repo: Repository</code>: Information on the upstream repository (if available).</li>
<li><code>secrets: {[key: string]: string}</code>: Key/value pairs of secret name and secret value.
The security model <em>may</em> limit access to this property or its values.</li>
</ul>

<p>Secrets (<code>project.secrets</code>) are passed from the project configuration into a Kubernetes Secret, then injected into Brigade.</p>

<p>So <code>helm install brigade-project --set secrets.foo=bar</code> will add <code>foo: bar</code> to
<code>project.secrets</code>.</p>

<h3 id="the-event-object">The <code>Event</code> object</h3>

<p>The Event object describes an event.</p>

<p>Properties:</p>

<ul>
<li><code>type</code>: The event type (e.g. <code>push</code>)</li>
<li><code>provider</code>: The entity that caused the event (<code>github</code>)</li>
<li><code>revision</code>: The <a href="#the-revision-object">Revision</a> object containing details for the commit that this script should operate on.</li>
<li><code>payload</code>: The object received from the event trigger. For GitHub requests, its
the data we get from GitHub.</li>
</ul>

<h3 id="the-job-object">The <code>Job</code> object</h3>

<p>To create a new job:</p>

<pre><code class="language-javascript">j = new Job(name);
</code></pre>

<p>Parameters:</p>

<ul>
<li>A job name (alpha-numeric characters plus dashes).</li>
</ul>

<p>Properties:</p>

<ul>
<li><code>name</code>: The name of the job</li>
<li><code>image</code>: A Docker image with optional tag.</li>
<li><code>tasks</code>: An array of commands to run for this job</li>
<li><code>shell</code>: The terminal emulator that job tasks will be executed under. By default,
this is /bin/sh</li>
<li><code>env</code>: Key/value pairs or Kubernetes value references that will be injected into the environment.

<ul>
<li>If supplying key/value, the key is the variable name (<code>MY_VAR</code>), and the value is the string value (<code>foo</code>)</li>
<li>If you are referencing existing Secrets or ConfigMaps in your Kubernetes cluster, the <code>env</code> object key
will be your secret name, and the value will be a Kubernetes reference object. <code>fieldRef</code>, <code>secretKeyRef</code>,
and <code>configMapKeyRef</code> are accepted. <code>resourceFieldRef</code> is technically supported but not advised, since resources
are not generally specified for Brigade jobs.</li>
<li>Example:
<code>javascript
myJob.env = {
myOneOffSecret: &quot;secret value&quot;,
myConfigReference: {
configMapKeyRef: {
  name: &quot;my-configmap&quot;,
  key: &quot;my-configmap-key&quot;
}
},
mySecretReference: {
secretKeyRef: {
  name: &quot;my-secret&quot;,
  key: &quot;my-secret-key&quot;
}
}
};
</code></li>
</ul></li>
</ul>

<p>It is common to pass data from the <code>e.env</code> Event object into the Job object as is appropriate:</p>

<pre><code class="language-javascript">events.push = function(e) {
  j = new Job(&quot;example&quot;);
  j.env = { DB_PASSWORD: project.secrets.dbPassword };
  //...
  j.run();
};
</code></pre>

<p>The above will make <code>$DB_PASSWORD</code> available to the &ldquo;example&rdquo; job&rsquo;s runtime.</p>

<p>Methods:</p>

<ul>
<li><code>run()</code>: Run this job and wait for it to exit.</li>
<li><code>background()</code>: Run this job in the background.</li>
<li><code>wait()</code>: Wait for a backgrounded job to complete.</li>
</ul>

<h3 id="the-repository-class">The <code>Repository</code> Class</h3>

<p>The <code>Repository</code> class describes a project&rsquo;s VCS repository (if provided).</p>

<ul>
<li><code>name: string</code>: The name of the repo (<code>org/name</code>)</li>
<li><code>cloneURL: string</code>: The URL that the VCS software can use to clone the repository.</li>
</ul>

<hr />

<p>Prev: <a href="scripting.md">Scripting Guide</a> <code>|</code> Next: <a href="scripting_advanced.md">Scripting Guide - Advanced</a></p>

<p>Return to the <a href="index.md">Table of Contents</a></p>
<div class="edit-meta">
<br></div><nav class="pagination"><a class="nav nav-prev" href="/topics/testing/" title="Testing"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Testing</a>
<a class="nav nav-next" href="/topics/workers/" title="Workers">Next - Workers <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav></article>
<footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">
<nav>
<ul>
<li class=""><a href="/">Home</a></li>

<li class=""><a href="/intro/">Getting Started</a>
<ul class="">
<li class=""><a href="/intro/overview/">Brigade Overview</a></li>
<li class=""><a href="/intro/install/">Installing Brigade</a></li>
<li class=""><a href="/intro/tutorial01/">Tutorial 1: Writing a CI pipeline</a></li>
<li class=""><a href="/intro/tutorial02/">Tutorial 2: Setup GitHub</a></li>
<li class=""><a href="/intro/tutorial03/">Tutorial 3: Projects &amp; Events</a></li>
<li class=""><a href="/intro/tutorial04/">Tutorial 4: Writing a Test</a></li>
<li class=""><a href="/intro/writing-efficient-pipelines/">Tutorial 5: Writing Efficient Pipelines</a></li>
<li class=""><a href="/intro/readnext/">What to Read Next</a></li>
</ul>
  
</li>

<li class="parent"><a href="/topics/">Topic Guides</a>
<ul class="sub-menu">
<li class=""><a href="/topics/scripting_advanced/">Advanced Scripting Guide</a></li>
<li class=""><a href="/topics/dockerhub/">Container Registry Integration</a></li>
<li class=""><a href="/topics/dependencies/">Dependencies</a></li>
<li class=""><a href="/topics/design/">Design</a></li>
<li class=""><a href="/topics/developers/">Developer Guide</a></li>
<li class=""><a href="/topics/gateways/">Gateways</a></li>
<li class=""><a href="/topics/genericgateway/">Generic Gateway</a></li>
<li class=""><a href="/topics/github/">GitHub Integration</a></li>
<li class=""><a href="/topics/ingress/">Ingress</a></li>
<li class=""><a href="/topics/projects/">Managing Projects in Brigade</a></li>
<li class=""><a href="/topics/releasing/">Releasing Brigade</a></li>
<li class=""><a href="/topics/scripting/">Scripting Guide</a></li>
<li class=""><a href="/topics/secrets/">Secret Management</a></li>
<li class=""><a href="/topics/security/">Securing Brigade</a></li>
<li class=""><a href="/topics/storage/">Storage</a></li>
<li class=""><a href="/topics/testing/">Testing</a></li>
<li class="active"><a href="/topics/javascript/">The Brigade.js API</a></li>
<li class=""><a href="/topics/workers/">Workers</a></li>
</ul>
  
</li>
</ul>
</nav>


<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
