<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Brigade Documentation on Brigade</title>
    <link>/</link>
    <description>Recent content in Brigade Documentation on Brigade</description>
    <generator>Hugo -- gohugo.io</generator>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Advanced Scripting Guide</title>
      <link>/topics/scripting_advanced/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/scripting_advanced/</guid>
      <description>Advanced Scripting Guide This guide provides some tips and ideas for advanced scripting. It assumes that you are familiar with the scripting guide and the JavaScript API.
Using async and await to run Jobs Recent versions of JavaScript added a new way of declaring asynchronous methods, and then calling them. This way is compatible with promises. Brigade supports the new async and await decorators.
Here&amp;rsquo;s a simple Promise chain that calls two jobs:</description>
    </item>
    
    <item>
      <title>Brigade Overview</title>
      <link>/intro/overview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/overview/</guid>
      <description>Brigade is a Kubernetes-native tool for doing event-driven scripting. Here&amp;rsquo;s what that means:
 Brigade is for running scriptable automated tasks in the cloud. Brigade does not require you to manage host servers. Brigade is particularly well suited for CI and CD workloads such as:  Automated testing GitHub hook integration Building artifacts and releases Managing deployments  Brigade is built directly on Kubernetes APIs, which means&amp;hellip;  You can deploy Brigade onto any stock Kubernetes system, from Azure to Minikube You can monitor Brigade and its jobs using Kubernetes tools (or with Brigade&amp;rsquo;s own tools, of course) Brigade uses Kubernetes resource types Brigade can be deployed and managed with helm.</description>
    </item>
    
    <item>
      <title>Container Registry Integration</title>
      <link>/topics/dockerhub/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/dockerhub/</guid>
      <description>Container Registry (DockerHub, ACR) Integration Brigade supports container registry webhooks such as the ones emitted by DockerHub and ACR. The following platforms are known to work with Brigade&amp;rsquo;s Container Registry gateway:
 DockerHub Azure Container Registry (ACR) with the Managed_* classes  DockerHub/ACR integration is not enabled by default.
Intro to Container Registry Webhook Integration Brigade comes with built-in support for container registry image pushing events. When a container registry webhook system is configured to notify Brigade&amp;rsquo;s GW server, Brigade will respond to an image push by triggering an image_push event.</description>
    </item>
    
    <item>
      <title>Dependencies</title>
      <link>/topics/dependencies/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/dependencies/</guid>
      <description>Import dependencies in your brigade.js file A Brigade worker is responsible for executing your brigade.js file. By default, Brigade comes with a general purpose worker which does not have any external dependency that is not critical to controlling the flow of your pipeline.
If you want to have other dependencies available in your worker execution environment (and available in brigade.js), there are multiple approaches:
 by creating a custom worker container image, which has your dependencies.</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>/topics/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/design/</guid>
      <description>Brigade Design This is a living document, and is kept up to date with the current state of Brigade. It is a high-level explanation of the Brigade design.
Brigade is an in-cluster runtime environment. It interprets scripts, and executes them often by invoking resources inside of the cluster. Brigade is event-based scripting of Kubernetes pipelines.
 Event-based: A script execution is triggered by a Brigade event. Scripting: Programs are expressed as JavaScript files that declare one or more event handlers.</description>
    </item>
    
    <item>
      <title>Developer Guide</title>
      <link>/topics/developers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/developers/</guid>
      <description>Developer Guide This document explains how to get started developing Brigade.
Brigade is composed of numerous parts. The following represent the core components:
 brigade-controller: The Kubernetes controller for delegating Brigade events brigade-worker: The JavaScript runtime for executing brigade.js files. The controller spawns these, though you can run one directly as well. brigade-api: The REST API server for user interfaces brigade-project: The Helm chart for installing Brigade projects brigade-vacuum: The stale build cleaner-upper (optional; enabled by default) brig: The Brigade CLI git-sidecar: The code that runs as a sidecar in cluster to fetch Git repositories (optional; enabled by default)  Additionally, there are several opt-in gateways that can be enabled via Helm chart values.</description>
    </item>
    
    <item>
      <title>Gateways</title>
      <link>/topics/gateways/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/gateways/</guid>
      <description>Brigade Gateways This guide explains how gateways work, and provides guidance for creating your own gateway.
What Is A Brigade Gateway? The Brigade architecture is oriented around the concept that Brigade scripts run as a response to one or more events. In Brigade, a gateway is an entity that generates events. Often times, it translates some external trigger into a Brigade event.
Brigade ships with the ability to enable various gateways that are ready to go.</description>
    </item>
    
    <item>
      <title>Generic Gateway</title>
      <link>/topics/genericgateway/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/genericgateway/</guid>
      <description>Generic Gateway Brigade contains a Generic Gateway that can be used to accept requests from other platforms or systems. Generic Gateway is a separate component in the Brigade system, like Github and Container Registry (CR) Gateways.
Generic Gateway is not enabled by default and provides Brigade developers with the ability to trigger scripts based on messages received from any platform that can send a POST HTTP request.
Intro to Generic Gateway Generic Gateway listens and accepts POST JSON messages at two different endpoints, /simpleevents/v1/:projectID/:secret and /cloudevents/v02/:projectID/:secret.</description>
    </item>
    
    <item>
      <title>GitHub Integration</title>
      <link>/topics/github/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/github/</guid>
      <description>GitHub Integration Brigade can optionally provide GitHub integration for triggering Brigade builds from GitHub events via the Brigade Github App project. By default, this gateway is disabled.
To get set up, follow the instructions to create and configure a GitHub App. This App can then be used across one or more repositories, as opposed to the older, OAuth approach requiring configuration for each individual respository.
Next, to enable this gateway for a Brigade installation, set the brigade-github-app.</description>
    </item>
    
    <item>
      <title>Ingress</title>
      <link>/topics/ingress/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/ingress/</guid>
      <description>Using an ingress So you&amp;rsquo;ve got yourself a Kubernetes cluster somewhere in the cloud and you want to expose all your Brigade gateways using a Kubernetes ingress, and you might also want to configure automatic TLS for each new ingress. This document will guide you through an opinionated way of achieving this. Note that you should be able to switch any component and replace it with something else.
Requirements To follow along, you will need:</description>
    </item>
    
    <item>
      <title>Installing Brigade</title>
      <link>/intro/install/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/install/</guid>
      <description>This part is a work-in-progress because Brigade is still developer-oriented
The Brigade server is deployed via its Helm chart and Brigade projects are managed via brig. Here are the steps:
 Make sure helm is installed, and helm version returns the correct server. Add the Brigade repo: helm repo add brigade https://azure.github.io/brigade-charts Install Brigade: helm install brigade/brigade --name brigade-server Create a Brigade project: brig project create  At this point, you have a running Brigade service.</description>
    </item>
    
    <item>
      <title>Managing Projects in Brigade</title>
      <link>/topics/projects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/projects/</guid>
      <description>Managing Projects in Brigade In Brigade, a project is just a special Kubernetes secret. The Brigade project currently offers two methods to create a project: via the brig cli and via the brigade-project Helm chart. The latter is managed in the Azure/brigade-charts repo and an in-depth overview of its configuration can be seen in the chart README.
This document explains how to use both methods for managing your Brigade projects.</description>
    </item>
    
    <item>
      <title>Releasing Brigade</title>
      <link>/topics/releasing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/releasing/</guid>
      <description>Releasing Brigade Once the intended commit has been tested and we have confidence to cut a release, we can follow these steps to release Brigade:
 Issue a docs pull request with all &amp;lt;current release&amp;gt; strings updated to &amp;lt;anticipated release&amp;gt;, e.g. 0.19.0 becomes 0.20.0.
(Note: amending docs/index.yaml is not required. This file still exists (as of writing) only to serve older chart versions for a period of time after the chart migration to Azure/brigade-charts completed.</description>
    </item>
    
    <item>
      <title>Scripting Guide</title>
      <link>/topics/scripting/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/scripting/</guid>
      <description>Scripting Guide This guide explains the basics of how to create and structure brigade.js files.
Brigade Scripts, Projects, and Repositories Brigade scripts are stored in a brigade.js file. They are designed to contain short scripts that coordinate running multiple related tasks. We like to think of these as cluster-oriented shell scripts: The script just ties together a bunch of other programs.
At the very core, a Brigade script is simply a JavaScript file that is executed within a special cluster environment.</description>
    </item>
    
    <item>
      <title>Secret Management</title>
      <link>/topics/secrets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/secrets/</guid>
      <description>Secret Management Brigade provides tools for storing sensitive data outside of your brigade.js scripts, and then passing that information into the jobs that need them. Brigade accomplishes this by making use of Kubernetes secrets.
Adding a Secret to Your Project Imagine a case where we need to pass a sensitive piece of information to one of the jobs in our brigade.js. For example, we might need to pass an authentication token to a job that must authenticate to a remote service.</description>
    </item>
    
    <item>
      <title>Securing Brigade</title>
      <link>/topics/security/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/security/</guid>
      <description>Securing Brigade The execution of Brigade scripts involves dynamically creating (and destroying) a number of Kubernetes objects, including pods, secrets, and persistent volume claims. For that reason, it is prudent to configure security.
 Isolate Brigade in a namespace: It is best to run Brigade in its own namespace. For example, in a Helm install, do helm install --namespace brigade .... RBAC Enabled: When installing with Helm, role-based access control is enabled by default.</description>
    </item>
    
    <item>
      <title>Storage</title>
      <link>/topics/storage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/storage/</guid>
      <description>How Brigade uses Kubernetes Persistent Storage Brigade allows script authors to declare two kinds of storage:
 per-job caches, which persist across builds per-build shared storage, which exists as long as the build is running  Usage of these is described within the JavaScript docs and the scripting guide.
This document describes the underlying Kubernetes architecture of these two storage types.
Brigade and PersistentVolumeClaims Brigade provisions storage using Kubernetes PVCs.</description>
    </item>
    
    <item>
      <title>Testing</title>
      <link>/topics/testing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/testing/</guid>
      <description>Testing Brigade Scripts Now that we&amp;rsquo;ve written our brigade.js scripts, we&amp;rsquo;re ready to confirm that the Javascript is correct and functioning as intended. Here we demonstrate the use of a few utilities we can employ to do so.
Javascript testing with brigtest brigtest is a testing tool designed to vet the Javascript portion of a brigade.js script without actually launching any containers or requiring a Kubernetes cluster. It can optionally mock events, Jobs and projects.</description>
    </item>
    
    <item>
      <title>The Brigade.js API</title>
      <link>/topics/javascript/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/javascript/</guid>
      <description>The Brigade.js API This document describes the public APIs typically used for writing Brigade.js. It does not describe internal libraries, nor does it list non-public methods and properties on these objects.
An Brigade JavaScript file is executed inside of a cluster. It runs inside of a Node.js-like environment (with a few libraries blocked for security reasons). It uses Node 8.
High-level Concepts An Brigade JS file is always associated with a project.</description>
    </item>
    
    <item>
      <title>Tutorial 1: Writing a CI pipeline</title>
      <link>/intro/tutorial01/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/tutorial01/</guid>
      <description>Writing your first CI pipeline, Part 1 Let’s learn by example.
Throughout this tutorial, we’ll walk you through the creation of a basic web application with a Brigade CI pipeline for testing the application.
It’ll consist of two parts:
 A public site that lets people generate UUIDs. A brigade.js that tests the site  We’ll assume you have Brigade, git (a version control system), and pip (a package management system for Python) installed already.</description>
    </item>
    
    <item>
      <title>Tutorial 2: Setup GitHub</title>
      <link>/intro/tutorial02/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/tutorial02/</guid>
      <description>Writing your first CI pipeline, Part 2 This tutorial begins where Tutorial 1 left off. We’ll walk through the process for using Git locally on your personal computer, and using Github to back it up. We&amp;rsquo;ll walk through creating your personal Github account, setting up Git on your computer, starting your first Git repository, and connecting that repository to a Github repository.
What are git and Github? Git is a widely-used version control system used to manage code.</description>
    </item>
    
    <item>
      <title>Tutorial 3: Projects &amp; Events</title>
      <link>/intro/tutorial03/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/tutorial03/</guid>
      <description>Writing your first CI pipeline, Part 3 This tutorial begins where Tutorial 2 left off. We’ll walk through the process for configuring your newly created Github repository with Brigade for testing new features. We&amp;rsquo;ll configure a new Brigade project, and have Github push events to trigger Brigade builds.
Create a Brigade project The Brigade server tracks separate configuration for each project you set up. To create and manage these configurations, we use the brig cli.</description>
    </item>
    
    <item>
      <title>Tutorial 4: Writing a Test</title>
      <link>/intro/tutorial04/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/tutorial04/</guid>
      <description>Writing your first CI pipeline, Part 4 This tutorial begins where Tutorial 3 left off. We’ll walk through the process for writing your first feature for our UUID generator app, then test the feature on Github using Brigade.
Test the application Let’s check that the application shows a UUID if we access the root of the application (/). Let&amp;rsquo;s create a test directory to write our tests:
$ mkdir tests/ $ touch tests/__init__.</description>
    </item>
    
    <item>
      <title>Tutorial 5: Writing Efficient Pipelines</title>
      <link>/intro/writing-efficient-pipelines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/intro/writing-efficient-pipelines/</guid>
      <description>Advanced tutorial: Writing efficient pipelines FIXME: This tutorial could use some love
This advanced tutorial begins where [Tutorial 4][part4] left off. We’ll be parallelizing a few operations in brigade.js into separate jobs so the job can fail faster and run as fast as possible.
If you haven’t recently completed Tutorials 1–4, we strongly encourage you to review these so that your example project matches the one described below.
Here are a few things to help you:</description>
    </item>
    
    <item>
      <title>What to Read Next</title>
      <link>/topics/readnext/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/readnext/</guid>
      <description>What to Read Next So you’ve read all the introductory material and have decided you’d like to keep using Brigade to test your applications. We’ve only just scratched the surface.
So what’s next?
Well, we’ve always been big fans of learning by doing. At this point you should know enough to start a project of your own and start fooling around. As you need to learn new tricks, come back to the documentation.</description>
    </item>
    
    <item>
      <title>Workers</title>
      <link>/topics/workers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/topics/workers/</guid>
      <description>Adding custom libraries to a Brigade worker A worker is the component in Brigade that executes a brigade.js. Brigade ships with a general purpose worker focused on running jobs. This generic worker exposes a host of Node.js libraries to brigade.js files, as well as the brigadier Brigade library.
Sometimes, though, it is desirable to include additional libraries &amp;ndash; perhaps even custom libraries &amp;ndash; to your workers. There are two ways of adding custom dependencies to a Brigade worker:</description>
    </item>
    
  </channel>
</rss>